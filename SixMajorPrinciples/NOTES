在运用面向对象的思想进行软件设计时，需要遵循六大原则:
----------------------------------------------------------------
 1. [ 单一职责原则 (Single Responsibility Principle) ]:
    一个类应该只有一个发生变化的原因。如果一个类有多于一个动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能地遵守单一职责原因。此原则的核心就是解耦和增强内聚性。
    优点：
    + 降低了类的复杂度。一个类只负责一项职责比负责多项职责要简单得多。
    + 提高了代码的可读性。 一个类简单了，可读性自然就提高了。
    + 提高了系统的可维护性。代码的可读性提高了，并且修改一项职责对其他职责影响降低了，可以维护性自然就提高了。
    + 变更引起的风险降低了。单一职责的最大优点就是修改一个功能，对其他功能的影响显著降低。
    缺点：
    我们必须要意识到，一味地遵守单一职责原则，不停地分拆类所付出的开销是很大的。这时候就涉及到平衡问题，平衡单一职责原则与修改造成的开销。如果一个方法逻辑不复杂的情况下，可以修改方法实现，否则要拆分为两个方法；如果一个类方法不多的情况下，可以只增加方法，而不用分拆为多个类，否则要拆分为多个类

----------------------------------------------------------------
 2. [ 里氏替换原则(Liskov Substitution Principle) ]:
    严格定义：如果对每一个类型为T1的对象O1，都有类型为T2的对象O2，使得以T1定义的所有程序P在所有的对象都换成O2时，程序P的行为没有变化，那么类型T2是类型T1的子类型。
    通俗定义：所有引用基类的地方必须能透明地使用其子类的对象。
    更通俗地定义：子类可以扩展父类的功能，但不能改变父灰原有的功能。

    里氏替换原则包含以下4层含义:
    + 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法 ->
      我们在做系统设计时，经常会设计接口或抽象类，然后由子类来实现抽象方法，这里使用的其实就是里氏替换原则。子类可以实现父类的抽象方法很好理解。里氏替换原则的关键点在于不能覆盖父类的非抽象方法。父类中凡是已经实现好的方法，实现上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些规范，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。 
    + 子类中可以增加自己特有的方法 ->
      在继承父类属性和方法的同时，每个子类也都可以有自己的个性，在父类的基础上扩展自己的功能。
      
    + 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 ->
       
    + 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。->
     
    继承作为面向对象的三大特性之一，在给程序设计带来巨大便利的同时，也带来了一些弊端，它增加了对象之间的耦合性。因此在系统设计时，遵循里氏替换原则，尽量避免子类重写父类的方法，可以有效降低代码出错的可能性。

----------------------------------------------------------------
 3. 依赖倒置原则(Dependence Inversion Principle)
    原始定义：High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.

    即三层含义: 
     + 高层模块不应该依赖低层模块，两者都应该依赖于其抽象。
     + 抽象不应该依赖于细节
     + 细节应该依赖抽象 

   抽象：即抽象类或接口，两者是不能够实例化的。
   细节：即具体的实现类，实现接口或者继承抽象类所产生的类，两者可以通过关键字new直接被实例化。

   倒置思维，提取公共的抽象，面向接口编程，不再依赖于具体实现，而是依赖于接口或抽象类，这就是依赖的思维方法“倒置”了。

   对象的依赖关系有三种方式来传递：
   + 接口方法中声明依赖对象
   + 构造方法传递依赖对象。在构造函数中的需要传递的参数是抽象类或接口的方法实现
   + Setter方法传递依赖对象。在setXXX方法中的参数为抽象类或接口。
 
   优点：
     由于类之间松耦合的设计，面向接口编程依赖抽象而不依赖于细节，所以在修改某个类代码时不会牵涉到其他类的修改，显著降低系统风险，提高系统健壮性。另外遵循依赖倒置原则提取抽象，可以在多人团队协作的开发中多模块并行开发，提高开发进度。
  总结：
     依赖倒置原则的核心就是面向接口编程的思想，尽量对每个实现类都提取抽象和公共接口形成接口或抽象类，依赖于抽象而不依赖于具体实现。其本质就是通过抽象使各个类或模块的实现彼此独立，不相互影响，实现模块之间的松耦合。但是这个原则也是六大原则中最难以实现的，如果没有实现这个原则，那么也就意味着开闭原则（对扩展放开，对修改关闭）也无法实现了。

----------------------------------------------------------------
 4. 接口隔离原则(Interface Segregation Principle)
    两种定义:
     + Clients should not be forced to depend upon interfaces that they don't use.
     + The dependency of one class to another one should depend on the smallest possible interface.

     客户端不应该依赖于它不需要的接口，就是说客户端只依赖它需要的接口，它需要什么接口就提供什么接口，不提供多余的接口。接口中的方法应该尽量少，不要使用接口过于臃肿，不要有很多不相关的逻辑方法。

     与单一职责原则的区别：
     + 单一职责原则注重的是职责；而接口隔离原则注重对接口依赖的隔离
     + 单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口，主要针对对象，针对程序整体框架的构建。

     注意：
      原则是前人经验的总结，在软件设计中具有一定的指导作用，但是不能完全照搬这些原则。对于接口隔离原则来说，接口尽量小，但是也要有限度。对接口进行细化可以提高程序设计灵活性是不争的事实，但是如果过小，则会造成接口数量过多，使设计复杂化，所以一定要适度。

----------------------------------------------------------------
 5. 迪米特法则(Law Of Demeter)
    迪米特法则有很多种说法，比如，一个类应该对其他类尽可能了解地最少；类只与直接的朋友通信等，但是最终目的只有一个，就是让类间解耦。
    定义：
     也称为最少知识原则，就是说一个对象应该对其他对象保持最少的了解，正如最少知识原则这个定义一样，一个类应该对其耦合的其他类或所调用的类知道得最少。所耦合的类内部无论如何复杂，怎样实现都无需知道，而只需要调用公布出来的接口。

----------------------------------------------------------------
 6. 开闭原则(Open Close Principle)
    开闭原则是设计模式六大原则中最重要也是最"虚"的一个原则。为什么说它重要呢？因为前面五大原则的目的都是为了实现这个开闭原则，开闭原则相当于它们的主旨思想。为什么说它"虚"呢，因为开闭原则只是个指导思想，不像另外五大原则有具体可行的方法。
    定义:
    Software entities like classes, modules and functions should be open for extension but closed for modification.

    开闭原则的定义很短，就是对扩展开放，对修改关闭。为什么要遵守这一原则呢。
    做过实际项目应该会深有体会，一个软件在其生命周期内都会发生很多变化，这几乎是不可避免的。无论是需求的变化、业务逻辑的变化、程序代码的变化乖乖，这些变化都有可能会整个软件的稳定性造成一定的威胁。而开闭原则就是应对这些变化的，它告诉我们应该通过扩展来实现变化，而不是通过修改已有的代码。


