////////////////////////////////////////////////////////////////////////
1. 单例模式
   定义: 确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
   类型: 创建类模式
         << 单例类>> Singleton
         - Singleton singleton   <------|
         + Singleton getInstance()  ----|
   包含要素:
       + 私有构造方法
       + 指向自己实例的私有静态引用
       + 以自己实例为返回值的静态的公有的方法

   单例模式根据实例化对象时机的不同分为两种: 一种是饿汉式单例，一种是懒汉式单例。饿汉式单便在单例类被加载时候，就实例化一个对象交给自己的引用; 而懒汉式在调用取得实例方法的时候才会实例化对象。  
   
   优点:
     + 在内存中只有一个对象，节省内存空间
     + 避免频繁的创建销毁对象，可以提高性能
     + 避免对共享资源的多重战胜
     + 可以全局访问

   适用场景:
     + 需要频繁实例化然后销毁的对象
     + 创建对象时耗时过多或者耗资源过多，但又经常用到的对象
     + 有状态的工具类对象
     + 频繁访问数据库或文件的对象
     + 要求只有一个对象的场景

   注意事项:
     + 只能使用单例类提供的方法得到单便对象
     + 不要做断开单例类对象与类中静态引用的危险操作
     + 多线程使用单例共享资源时，注意线程安全问题

////////////////////////////////////////////////////////////////////////
2. 工厂模式
   定义: 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类
           <<工厂接口>>IFactory         <<产品接口>>IProduct
           + createProduct               + productMethod()
                  /\                           /\
                  |                             |
           <<工厂实现>>Factory            <<产品实现>>Product

    工厂模式根据抽象程序的不同分为三种: 简单工厂模式（也叫静态工厂模式),工厂方法模式和抽象工厂模式。
    优点:
      + 可以使代码结构清晰，有效地封装变化。在产品类的实例化时有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品实例化过程 ，只需要依赖工厂即可得到自己想要的产品.
      + 对调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了，即使产品的实现变更了，对调用者来说也没有任何影响。
      + 降低耦合度，产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对调用者来说根本无需知道。

    工厂方法模式:
       + 工厂接口。工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。在实际中有时候也会使用一个抽象来作为与调用者交互的接口其本质上是一样的。
       + 工厂实现。工厂实现决定如何实例化产品，是实现扩展的途径，需要多少种产品就需要有多少个具体的工厂实现。
       + 产品接口。产品接口的主要目的是定义产品的规范，所有的产品实现都必须遵循产品接口定义的规范，产品接口定义的优劣直接决定了调用者代码的稳定性。同样，产品接口也可以用抽象类来代替，但是注意最好不要违反里氏替换原则 。
       + 产品实现。实现产品接口的具体类，决定了产品在客户端中的具体行为。

    适用场景:
       + 作为一种创建类模式，在任何地方需要生成复杂对象的地方，都可以使用工厂方法模式。而简单对象，特别是只需要通过new就可以创建的对象，无需使用工厂模式。使用工厂模式需要引入一个工厂类，会增加系统的复杂度。如果生产一辆汽车需要组装轮子、发动机、底盘等，过程比较复杂，可以用工厂来封装。
       + 工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现地尤为明显。假如调用自己组装产品需要增加依赖关系时，可以考虑使用工厂模式，将会大大降低对象之间的耦合度。
        + 由于工厂模式是依赖抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。


    抽象工厂模式:
      抽象工厂模式是工厂方法模式的升级版本，它用来创建一组相关或者相互依赖的对象。它与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则是针对多个产品等级结构。在抽象方法中有个产品族的概念，即位于不同产品等级结构中功能相关联的产品组成的家庭。抽象工厂模式所提供的一系列产品就组成一个产品族，而工厂方法提供的一系列产品就称为一个等级结构。
////////////////////////////////////////////////////////////////////////
      优点:
       + 抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束，所谓的产品族，一般或多或少都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述。

      缺点:
       + 产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。

       适用场景:
        + 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。就是一个继承体系中，如果存在着多个等级结构（即存在多个抽象类），并且分属各个等级结构中的实现类之间存在一定的关联或约束，就可以使用抽象工厂模式。

////////////////////////////////////////////////////////////////////////
3. 建造者模式
   定义: 将一个复杂对象的构建与它的表示分享，使得同样的构建过程可以创建不同的表示。

         <<导演类>>Director  -----> <<抽象建造者>>IBuilder
          + getProduct()              + setPart()
                                      + getProduct()
                                          /\
                                           |
                                        <<建造者>>Builer ---> <<产品类>>Product
    四个要素:
     + 产品类: 一般是一个较为复杂的对象，也就是创建对象的过程比较复杂，一般会有较多的代码量。实际中产品类可以是一个抽象类与它的不同实现，也可以是由多个抽象类与它们的实现组成。
     + 抽象建造者: 引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现，这样更容易扩展，一般至少会有两个抽象方法，一个用那建造产品，一个用来返回产品。
     + 建造者: 实现抽象类的所有未实现方法，具体来说一般是两项任务: 组建产品; 返回组建好的产品
     + 导演类: 负责调用适当来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。

    优点:
      + 首先，建造者模式的封装性很好。在使用建造者模式的场景中，一般产品类和建造类是比较稳定的，因此，将主要业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。
      + 建造者模式很容易进行扩展。如果有新需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码。

    建造者模式与工厂模式很像，总体上，建造者模式仅仅比工厂模式多了一个”导演类“角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么剩余的部分就可以看作一个简单的工厂模式了。
    与工厂模式相比，建造者模式一般用来创建一个更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立 出来组成一个新类--导演类。也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品;而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。

////////////////////////////////////////////////////////////////////////
4. 原型模式
   定义: 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

    <<调用类>>Client -----> <<原型类>>Prototype
                              + clone()
                                  /\
                                  ||
                            <<子类>>ConcretePrototype

    原型模式主要用于对象的复制，它的核心就是原型类Prototype。需要实现Clone函数。对于C++来说，其实就是拷贝构造函数，需实现深拷贝.

    优点:
      + 使用原型模式可以简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。

    注意:
      + 深拷贝与浅拷贝。
////////////////////////////////////////////////////////////////////////


      创建类模式总结:
        + 单例模式: 用于得到内存中的唯一对象
        + 工厂方法模式: 用于创建复杂的对象
        + 抽象工厂方法模式: 用于创建一组相关或相互依赖的复杂对象
        + 建造者模式: 用于创建模块化的更加复杂的对象
        + 原型模式: 用于得到一个对象的拷贝
      
      为什么要使用创建类模式:
         + 在编程中，对象的创建通常是一件比较复杂的事，因为为了达到降低耦合的目的通常会采用面向抽象编程，对象间的关系不会硬编码到类中，而是等到调用的时候再进行组装，这样虽然降低了对象间的耦合，提高了对象复用的可能，但在一定程序上将组装类的任务都交给了最终调用的客户端程序 ，大大增加了客户端的复杂度。采用创建类模式优点之一就是将组装对象的过程封装到一个单独的类中，这样既不会增加对象间的耦合，又可以最大限度的减小客户端的负担。
         + 使用普通的方式创建对象一般是返回一个具体的对象，即所谓的面向实现编程。这与设计模式原则相违背。采用创建类模式则可以实现面向抽象编程。客户端要求的只是一个抽象的类型，具体返回什么样的对象，由创建者决定。
       
      所有的创建类模式本质上都是对对象的创建过程进行封装。

////////////////////////////////////////////////////////////////////////
5. 模板方法模式
   定义: 定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤.
   类型: 行为类模式
   类图: 
         <<抽象类>>AbstractClass
          # otherMethod()
          + templateMethod()
                /\
                ||
            <<实现类>>ConcreteClass
    抽象模板(AbstractClass)角色定义一个或多个抽象操作，以便让子类实现，这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。
    具体模板(ConcreteClass)角色实现父类所定义的一个或多个抽象方法它们是一个顶级逻辑的组成步骤。每个抽象模板角色都可以有任意多个具体模板与之对应，而每一个具体模板角色都可以给出这些抽象方法的不同实现。

    结构:
    + 抽象方法
    + 模板方法
    + 钩子方法
    
    适用性:
    + 一次实现一个算法的不变的部分，并将可变的行为留到子类实现。
    + 各个子类中公共的行为被提取出来并集中到一个公共父类中以避免代码重复。
    + 控制子类的扩展。模板方法只在特定点调用"Hook"操作，这样就只允许在这些点进行扩展.

    要点:
    + Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制(虚函数的多态性)为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。
    + 除了可以灵活应对子步骤的变化外，还可以反向控制结构

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
