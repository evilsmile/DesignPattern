////////////////////////////////////////////////////////////////////////
1. 单例模式
   定义: 确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
   类型: 创建类模式
         << 单例类>> Singleton
         - Singleton singleton   <------|
         + Singleton getInstance()  ----|
   包含要素:
       + 私有构造方法
       + 指向自己实例的私有静态引用
       + 以自己实例为返回值的静态的公有的方法

   单例模式根据实例化对象时机的不同分为两种: 一种是饿汉式单例，一种是懒汉式单例。饿汉式单便在单例类被加载时候，就实例化一个对象交给自己的引用; 而懒汉式在调用取得实例方法的时候才会实例化对象。  
   
   优点:
     + 在内存中只有一个对象，节省内存空间
     + 避免频繁的创建销毁对象，可以提高性能
     + 避免对共享资源的多重战胜
     + 可以全局访问

   适用场景:
     + 需要频繁实例化然后销毁的对象
     + 创建对象时耗时过多或者耗资源过多，但又经常用到的对象
     + 有状态的工具类对象
     + 频繁访问数据库或文件的对象
     + 要求只有一个对象的场景

   注意事项:
     + 只能使用单例类提供的方法得到单便对象
     + 不要做断开单例类对象与类中静态引用的危险操作
     + 多线程使用单例共享资源时，注意线程安全问题

////////////////////////////////////////////////////////////////////////
2. 工厂模式
   定义: 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类
           <<工厂接口>>IFactory         <<产品接口>>IProduct
           + createProduct               + productMethod()
                  /\                           /\
                  |                             |
           <<工厂实现>>Factory            <<产品实现>>Product

    工厂模式根据抽象程序的不同分为三种: 简单工厂模式（也叫静态工厂模式),工厂方法模式和抽象工厂模式。
    优点:
      + 可以使代码结构清晰，有效地封装变化。在产品类的实例化时有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品实例化过程 ，只需要依赖工厂即可得到自己想要的产品.
      + 对调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了，即使产品的实现变更了，对调用者来说也没有任何影响。
      + 降低耦合度，产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对调用者来说根本无需知道。

    工厂方法模式:
       + 工厂接口。工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。在实际中有时候也会使用一个抽象来作为与调用者交互的接口其本质上是一样的。
       + 工厂实现。工厂实现决定如何实例化产品，是实现扩展的途径，需要多少种产品就需要有多少个具体的工厂实现。
       + 产品接口。产品接口的主要目的是定义产品的规范，所有的产品实现都必须遵循产品接口定义的规范，产品接口定义的优劣直接决定了调用者代码的稳定性。同样，产品接口也可以用抽象类来代替，但是注意最好不要违反里氏替换原则 。
       + 产品实现。实现产品接口的具体类，决定了产品在客户端中的具体行为。

    适用场景:
       + 作为一种创建类模式，在任何地方需要生成复杂对象的地方，都可以使用工厂方法模式。而简单对象，特别是只需要通过new就可以创建的对象，无需使用工厂模式。使用工厂模式需要引入一个工厂类，会增加系统的复杂度。如果生产一辆汽车需要组装轮子、发动机、底盘等，过程比较复杂，可以用工厂来封装。
       + 工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现地尤为明显。假如调用自己组装产品需要增加依赖关系时，可以考虑使用工厂模式，将会大大降低对象之间的耦合度。
        + 由于工厂模式是依赖抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。


    抽象工厂模式:
      抽象工厂模式是工厂方法模式的升级版本，它用来创建一组相关或者相互依赖的对象。它与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则是针对多个产品等级结构。在抽象方法中有个产品族的概念，即位于不同产品等级结构中功能相关联的产品组成的家庭。抽象工厂模式所提供的一系列产品就组成一个产品族，而工厂方法提供的一系列产品就称为一个等级结构。
////////////////////////////////////////////////////////////////////////
      优点:
       + 抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束，所谓的产品族，一般或多或少都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述。

      缺点:
       + 产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。

       适用场景:
        + 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。就是一个继承体系中，如果存在着多个等级结构（即存在多个抽象类），并且分属各个等级结构中的实现类之间存在一定的关联或约束，就可以使用抽象工厂模式。

////////////////////////////////////////////////////////////////////////
3. 建造者模式
   定义: 将一个复杂对象的构建与它的表示分享，使得同样的构建过程可以创建不同的表示。

         <<导演类>>Director  -----> <<抽象建造者>>IBuilder
          + getProduct()              + setPart()
                                      + getProduct()
                                          /\
                                           |
                                        <<建造者>>Builer ---> <<产品类>>Product
    四个要素:
     + 产品类: 一般是一个较为复杂的对象，也就是创建对象的过程比较复杂，一般会有较多的代码量。实际中产品类可以是一个抽象类与它的不同实现，也可以是由多个抽象类与它们的实现组成。
     + 抽象建造者: 引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现，这样更容易扩展，一般至少会有两个抽象方法，一个用那建造产品，一个用来返回产品。
     + 建造者: 实现抽象类的所有未实现方法，具体来说一般是两项任务: 组建产品; 返回组建好的产品
     + 导演类: 负责调用适当来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。

    优点:
      + 首先，建造者模式的封装性很好。在使用建造者模式的场景中，一般产品类和建造类是比较稳定的，因此，将主要业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。
      + 建造者模式很容易进行扩展。如果有新需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码。

    建造者模式与工厂模式很像，总体上，建造者模式仅仅比工厂模式多了一个”导演类“角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么剩余的部分就可以看作一个简单的工厂模式了。
    与工厂模式相比，建造者模式一般用来创建一个更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立 出来组成一个新类--导演类。也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品;而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。

////////////////////////////////////////////////////////////////////////
4. 原型模式
   定义: 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

    <<调用类>>Client -----> <<原型类>>Prototype
                              + clone()
                                  /\
                                  ||
                            <<子类>>ConcretePrototype

    原型模式主要用于对象的复制，它的核心就是原型类Prototype。需要实现Clone函数。对于C++来说，其实就是拷贝构造函数，需实现深拷贝.

    优点:
      + 使用原型模式可以简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。

    注意:
      + 深拷贝与浅拷贝。
////////////////////////////////////////////////////////////////////////


      创建类模式总结:
        + 单例模式: 用于得到内存中的唯一对象
        + 工厂方法模式: 用于创建复杂的对象
        + 抽象工厂方法模式: 用于创建一组相关或相互依赖的复杂对象
        + 建造者模式: 用于创建模块化的更加复杂的对象
        + 原型模式: 用于得到一个对象的拷贝
      
      为什么要使用创建类模式:
         + 在编程中，对象的创建通常是一件比较复杂的事，因为为了达到降低耦合的目的通常会采用面向抽象编程，对象间的关系不会硬编码到类中，而是等到调用的时候再进行组装，这样虽然降低了对象间的耦合，提高了对象复用的可能，但在一定程序上将组装类的任务都交给了最终调用的客户端程序 ，大大增加了客户端的复杂度。采用创建类模式优点之一就是将组装对象的过程封装到一个单独的类中，这样既不会增加对象间的耦合，又可以最大限度的减小客户端的负担。
         + 使用普通的方式创建对象一般是返回一个具体的对象，即所谓的面向实现编程。这与设计模式原则相违背。采用创建类模式则可以实现面向抽象编程。客户端要求的只是一个抽象的类型，具体返回什么样的对象，由创建者决定。
       
      所有的创建类模式本质上都是对对象的创建过程进行封装。

////////////////////////////////////////////////////////////////////////
5. 模板方法模式
   定义: 定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤.
   类型: 行为类模式
   类图: 
         <<抽象类>>AbstractClass
          # otherMethod()
          + templateMethod()
                /\
                ||
            <<实现类>>ConcreteClass
    抽象模板(AbstractClass)角色定义一个或多个抽象操作，以便让子类实现，这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。
    具体模板(ConcreteClass)角色实现父类所定义的一个或多个抽象方法它们是一个顶级逻辑的组成步骤。每个抽象模板角色都可以有任意多个具体模板与之对应，而每一个具体模板角色都可以给出这些抽象方法的不同实现。

    结构:
    + 抽象方法
    + 模板方法
    + 钩子方法
    
    适用性:
    + 一次实现一个算法的不变的部分，并将可变的行为留到子类实现。
    + 各个子类中公共的行为被提取出来并集中到一个公共父类中以避免代码重复。
    + 控制子类的扩展。模板方法只在特定点调用"Hook"操作，这样就只允许在这些点进行扩展.

    要点:
    + Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制(虚函数的多态性)为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。
    + 除了可以灵活应对子步骤的变化外，还可以反向控制结构

////////////////////////////////////////////////////////////////////////

6. 中介者模式
   定义: 定义一个中介对象来封装系列对象之间的交互。 中介者使各个对象不需要显示地相互引用，从而使其耦合性松散，而且可以独立地改变他们之间的交互。
   类型: 行为类模式
   类图:
      <<抽象中介者>>Mediator <----- <<同事类>>Colleague
          /\
          ||
        <<实现类>>ConcreteMediator

   结构:
    + 抽象中介者: 定义好同事类对象到中介者对象的接口，用于各个同事类之间的通信。一般包括一个或几个抽象的事件方法，并由子类去实现。
    + 中介实现类: 从抽象中介者继承而来，实现抽象中介者中定义的事件方法。从一个同事类接收消息，然后通过消息影响影响其他同事类。
    + 同事类: 如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。上图中省略了只有一个同事类，实际中一般同事类由多个组成，他们之间相互影响，相互依赖。同事类越多，关系越复杂。并且，同事类也可以表现为继承了同一个抽象类的一组实现。在中介者模式中，同事类之间必须通过中介者才能进行消息传递。


    为什么要使用中介者模式:
     + 一般来说，多个同事类之间相互关联时，他们之间的关系会呈现复杂的网状结构，这是一种过度耦合的架构，既不利于类的复用，也不稳定。
     如果引入中介者模式，那么同事类之间的关系将变成星型结构，中心就是中介者。任何一个类的变动，只会影响类的本身，以及中介者，从而减小系统的耦合。


    中介者模式是一种比较常用的模式，也是一种比较容易被滥用的模式。对于大多数情况，同事类之间的关系不会复杂到混乱不堪的网状结构，因此，大多数情况下，将对象间的依赖关系封装的同事类内部就可以，没有必要非得引入中介者模式。而且中介者承担了较多的责任，所以一旦这个中介对象出了问题，那么整个系统就会受到重大影响。
////////////////////////////////////////////////////////////////////////

7. 观察者模式

   定义: 定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。
   类型: 行为类模式
   类图:
        <<被观察者>>Subject        ---->    <<观察者>>Observer
        - Vector<Observer> vector            + update()
        + attach(Observer o)                     /\
        + detach(Observer o)                     ||
        + notify()                               ||
            /\                          <<实现类>>ConcreteObserver
            ||
        <<子类>>ConcreteSubject      

     编程中经常会有这样的需求: 如果一个对象的状态发生改变，某些与它相关的对象也要随之做出变化。即一个对象要时刻监听着另一个对象，只要它的状态一发生改变，自己随之要做出相应的行动。

     结构:
      + 被观察者: 一个用来存放观察者对象的Vector容器(之所以使用Vector而不使用List，是因为多线程操作时，Vector是安全的，而List则是不安全的)。这个Vector容器是被观察者类的核心。另外还有三个方法: attach方法是向这个容器中添加观察者对象; detach方法是从容器中移除观察者对象; notify方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或具体的类。
      + 观察者: 观察者角色一般是一个接口，它只有一个update方法，在被观察者状态发生变化时，这个方法就会被触发调用。
      + 具体的被观察者: 使用这个角色是为了便于扩展，可以在此角色中定义具体的业务逻辑。
      + 具体的观察者: 观察者接口的具体实现，在这个角色中，将定义观察者对象状态发生变化时所要处理的逻辑。

    适用场合:
    + 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。
    + 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。也就是说，你不希望这些对象是紧密耦合的。

    优点:
    + 观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察聚集，每一个具体观察者都符合一个抽象观察者接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象层次。
    + 观察者模式支持广播通信。被观察者会向所有的登记过的观察者发出通知。

    缺点:
    + 如果一个观察者对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
    + 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃，这一点要注意。
    + 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自洽的方式进行的。
    + 虽然观察者模式可以随时使观察者所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么变化的。


    观察者模式是一种常用的触发机制，它形成一条触发链，依次对各个观察塲方法进行处理。

////////////////////////////////////////////////////////////////////////

8. 访问者模式

   定义: 封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
   类型: 行为类模式
   类图:
         <<调用类>>Client  ------->  <<抽象访问者类>>Visitor
               |                 + visitConcreteElement(ConcreteLement element)
               |                                /\
               |                                ||
               |                        <<访问者类>>ConcretVisitor
               |
              \|/
        <<结构对象>>ObjectStructure ----> <<抽象元素>>Element
                                            + accept(Visitor vistor)
                                                    /|\
                                                     |
                                                     |
                                            <<元素类>>ConcreteElement

    访问者模式可能是行为类模式中最复杂的一种模式了。

    结构:
      + 抽象访问者: 抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。 
      + 访问者: 实现抽象访问者所声明的方法，这影响到访问者访问到一个类后该干什么，要做什么事情。
      + 抽象元素类: 接口或抽象类，声明接受哪一类访问者，程序上是通过accept方法中的参数来定义。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。
      + 元素类: 实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)
      + 结构对象: 一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器。


    优点:
     + 符合单一职责原则: 凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展。
     + 扩展性良好: 元素类可以通过接受不同的访问者来实现对不同操作的扩展。

    适用场景:
     + 假如一个对象中存在一些与本对象不相干（或关系较弱)的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。
     + 假如一组对象中，存在相似的操作，为了避免出现大量重复的代码，也可以将这些重复的操作封装到访问者中去。

    缺点:
     + 增加新的元素类比较困难。在访问者类中，每一个元素类都有它对应的处理方法，也就是说，每增加一个元素都要修改访问者类(也包括访问者类的子类或实现类)，修改起来相当麻烦。所以在元素类数目不确定的情况下，应该慎用访问者模式。所以，访问者模式比较适用于对已有功能的tgsq
////////////////////////////////////////////////////////////////////////

9. 命令模式
   定义: 将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求或者记录请求日志，可以提供命令的撤销和恢复功能。
   类型: 行为类模式
   类图:
       Client               <<调用者>>Invoker   ---->   <<抽象命令类>>Command
         | |                                              +execute()
         | |                                                /|\
         | |--------------> <<接收者>>Receiver <---------    |
         |                    + action()                 |   |
         |---------------------------------------->  <<命令类>>ConcreteCommand

    结构:
     + Command类: 是一个抽象类，类中对需要执行的命令进行声明，一般来说要对外公布一个execute方法用来执行命令。
     + ConcreteCommand类: Command的实现类，对抽象类中声明的方法进行实现。
     + Client类: 最终的客户端调用类。
     + Invoker类: 调用者，负责调用命令类。
     + Receiver类: 接收者，负责接收命令并且执行具体的命令。

    适用场景:
     + 对于大多数请求-响应模式的功能，比较适合使用命令模式，正如命令模式定义说的那样，命令模式对实现记录日志、撤销操作等功能比较方便。

    总结:
     + 命令模式是通过命令发送者和命令执行者解耦来完成对命令的具体控制，其根本目的在于将"行为请求者"和"行为实现者"解耦。
     + 实现Command接口的具体命令对象有时候根据需要可能会保存一些额外的状态信息
     + 命令模式是对功能方法的抽象，并不是对对象的抽象
     + 命令模式是将功能提升到对象来操作，以便对多个功能进行一系列的处理以及封装。

////////////////////////////////////////////////////////////////////////

10. 责任链模式
    定义: 使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。
    类型: 行为类模式
    类图:                                   |------------------------
           <<调用类>>Client     --->   <<处理类>>Handler            |
                                        - Hanadler nextHandler()  <-|
                                        + handleRequest()
                                                /|\
                                                 |
                                            <<子类>>ConcreteHandler


    结构:
     + 抽象处理类: 主要包含一个指向下一处理类的成员变量nextHandler和一个处理请求的方法handleRequest。handleRequest方法的主要思想是，如果满足处理的条件，则有本处理类来进行处理，否则由nextHandler来处理。
     + 具体处理类: 主要是对具体的处理逻辑和处理的适用条件进行实现。

   优点:
     + 耦合性要低，因为它把原来的条件判断分散到了各个处理类，而且处理顺序也可以随意设定。
   
   缺点:
     + 在找到正确的处理类之前，所有的判定条件都要被执行一遍，当责任链比较长时，性能问题比较严重。

   总结:
     + 责任链模式其实就是一个灵活版的if..else...，它将这些判定条件的语句放到了各个处理类中。
     + 设置处理类前后关系时，一定要特别仔细，搞好处理类前后逻辑的条件判断关系。注意不要在链中出现循环引用问题。
     + 一个请求链最后可能也没有处理，要注意配置得当。

////////////////////////////////////////////////////////////////////////

11. 策略模式
    定义: 定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。
    类型: 行为类模式
    类图:
       <<封装类>>Context          ----->       <<抽象策略>>Strategy
        + contextInterface()                     + algorithmInterface()
                                                            /|\
                                                             |
                                                             |
                                                <<实现>>ConcreteStrategy

    策略模式是对算法的封装，把一系列的算法分别封装到对应的类中，并且这些类实现相同的接口，相互之间可以替换。
    策略模式与模式方法模式的区别仅仅是多了一个单独的封装类Context，它与模板方法模式的区别在于后者调用算法的主体在抽象的父类中，而在策略模式中，调用算法的主体则封装在墙头类Context中，抽象策略Strategy一般只是一个接口，目的只是为了定义规范，里面一般不包含逻辑。

    结构:
     + 封装类: 也叫上下文，对策略进行二次封装，目的是避免高层模块对策略的直接调用。
     + 抽象策略: 通常情况下为一个接口，当各个实现类中存在重复的逻辑时，则使用抽象类来封装这部分公共的代码，此时，策略模式看上去更像是模版方法模式。
     + 具体策略: 通常由一组封装了算法的类来担任，这些类之间可以根据需要自由转换。

    优点:
     + 策略之间可以自由切换。由于策略类实现自同一个抽象，所以他们之间可以自由切换。
     + 易于扩展。增加一个新的策略对策略模式来说非常容易，基本上可以在不改变原有代码基础上进行扩展。
     + 避免使用多重条件，如果不使用策略模式，对于所有的算法必须使用条件语句进行连接，通过条件判断来使用哪一种。

    缺点:
     + 维护各个策略类会给开发带来额外开销。
     + 必须对客户端暴露所有的策略类，因为使用哪种策略是由客户端来决定的。因此客户端应该知道有什么策略，并且了解各个策略之间的区别。

    策略模式是一种常用的模式，它一般不会单独使用，跟模板方法模式、工厂模式等混合使用。
////////////////////////////////////////////////////////////////////////

12. 迭代器模式
    定义: 提供一种方法访问一个容器内部对象中各个元素，而又不暴露该对象内部细节。
    类型: 行为类模式
    类图:
       <<抽象容器>>Aggregate   ---->      <<抽象迭代器>>Iterator
         + contextInterface                + remove()
                |                          + next()
                |                          + hasNext()
                |                          + fisrt()
               \|/
        <<实现>>ConcreteAggregate  -->    <<实现>>ConcreteIterator


   结构:
    + 抽象容器: 一般是一个接口，提供一个iterator()方法
    + 具体容器: 就是抽象容器的具体实现类
    + 抽象迭代器: 定义遍历元素所需要的方法
    + 迭代器实现: 实现迭代器中定义的方法，完成集合的迭代

   
    实现要点:
     + 迭代抽象: 访问一个聚合对象的内容而无需暴露它的内部表示
     + 迭代多态: 为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。
     + 健壮性: 遍历的同时更改迭代器所在的集合结构，会导致问题。

    适用性:
     + 访问一个聚合对象的内容而无需暴露它的内部表示
     + 支持对聚合对象的多种遍历
     + 为遍历不同的聚合结构提供一个统一的接口(即，支持多态迭代)
     + 迭代器模式与集合共生共死，一般只要实现一个集合就需要同时提供这个集合的迭代器。


    优点:
     + 简化了遍历方式
     + 可以提供多种遍历方法，如正序、倒序，用户只需要使用已经实现好的迭代器
     + 封装性好，用户只要得到迭代器就可以遍历，而不关心遍历算法

////////////////////////////////////////////////////////////////////////

13. 解释器模式:
    定义: 给定一种语言，定义他的方法的一种表示，并定义一个解释器，该解释器使用该表示解释语言中的句子。
    类型: 行为类模式
    类图:
                         |-------->   <<环境角色>>Context
       <<客户端>>Client--|-------->    <<抽象解释器>>AbstractExpression <---|
                                         + algorithmInterface()             |
                                                /|\                         |
                                                 |                          |
                 |-------------------------------|--------------|           |
                 |                                              |           |
    <<终结符解释器>>TerminalExpression  <<非终结符解释器>>NonterminalExpression


    结构:
     + 抽象解释器: 声明一个所有具体表达式都要实现的抽象接口(或者抽象类). 接口中主要是一个interpret()方法，称为解释操作。具体解释任务由它的各个实现类来完成。具体的解释器分别由终结符解释器TerminalExpression和非终结符解释器NonterminalExpression完成。
     + 终结符表达式: 实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如一个简单的公式R=R1+R1，在里面R1和R2就是非终结符，对应的解析R1和R2的解释器就是终结符表达式。
     + 非终结符表达式: 方法中的每条规则对应一个非终结符表达式，非终结符表达式一般是方法中的运算符或者其他关键字，比如公式中的R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则是每个文法规则都对应一个非终结符表达式。
     + 环境角色: 这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如 R=R1+R2，我们给R1赋值100，给R2赋值200.这些信息需要存放到环境角色中。

    适用性:
     + 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树
     + 一些重复出现的问题可以用一种简单的语言来表达
     + 一个语言的方法较为简单
     + 执行效率不是关键问题（高效的解释器通常不是通过直接解释抽象语法树来实现，而是实现将它们转换成其他形式，使用解释器模式的效率并不高)

    优点:
     + 易于改变和扩展文法。由于在解释器模式中使用类来表达语言的文法规则，因此可以通过继承等机制来改变或扩展方法
     + 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言
     + 实现文法较为容易。在抽象语法树中每一个表达式节点的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。
     + 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式代码无须修改。

   缺点:
     + 对于复杂方法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多方法规则，类的个数将会急剧增加。
     + 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调度过程比较麻烦。

  总结:
     尽量不要在重要模块中使用解释器模式，因为维护困难。在项目中，可以使用脚本语言来代替解释器模式。

////////////////////////////////////////////////////////////////////////

14. 备忘录模式
    定义: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。
    类型: 行为类模式
    类图:
        <<发起人>>Originator  ----->  <<备忘录>>Memento <------ <<管理角色>>Caretaker
         + setMemento()                  + getState()
         + createMemento()               + setState()

    结构:
      + 发起人: 记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。
      + 备忘录: 负责存储发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。
      + 管理角色: 对备忘录进行管理，保存和提供备忘录。

    适用场景:
      + 适用功能比较复杂，但需要纪录或维护属性历史的类; 或者需要保存的属性只是众多属性中的一小部分时Originator可以根据保存的Memento还原到前一状态。

    优点:
      + 当发起人角色的状态有改变时，有可能是个错误的改变，我们使用备忘录模式就可以把这个错误改变还原。
      + 备份的状态是保存在发起人角色之外的，这样，发起人角色就不需要对各个备份的状态进行管理。

    缺点:
      + 如果备份的对象存在大量的信息或者创建、恢复操作非常频繁，则可能造成很大的性能开销.

////////////////////////////////////////////////////////////////////////

15. 状态模式
    定义: 允许一个对象在其内部状态改变时改变它的行为，使对象看起来似乎修改了它的类。
    类图:
    <<上下文环境>> Context    ----------> <<抽象状态>> State
        + Request                          + Handle()
           |                                 |
           |                                 |
           |                     ------------|-------------------------
          \|/                   \|/                      \|/                 .....
        state->Handle()     <<具体状态>ConcreteStateA   ConcreteStateB
                             + Handle()       + Handle()

    结构:
      + 上下文环境: 它定义了客户端程序需要的接口并维护一个具体状态角色的实例，将与状态相关的操作委托给当前的Concrete State对象来处理。
      + 抽象状态: 定义一个接口以封装使用上下文环境的一个特定状态相关的行为。
      + 具体状态: 实现抽象状态定义的接口。

    适用场景:
      + 状态械主要解决的是当控制一个对象封装的条件表达式过于复杂的情况。把状态的判断逻辑条件转移到不同的一系列类中，可以把复杂的判断逻辑简单化。
      + 当一个对象行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为。

    优点:
      + 状态模式将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。
      + 所有状态相关的代码都在于某个ConcreateState中，所以通过定义新的子类很容易地增加新的状态和转换。
      + 状态模式通过所各种状态转移逻辑分到不同的State子类之间，来减少相互依赖关系 。

    缺点:
      + 状态模式的结怨和实现都比较复杂，如果使用不当将导致程序结构和代码的混乱。

////////////////////////////////////////////////////////////////////////

16. 外观模式
    定义: 定义一个高层接口，该接口为子系统中的一组接口提供一个一致的界面，使得这一子系统更加容易使用。
         <<外观>>Facade
           + OperationWarpper()
             |   |
             |   |
        |----    ---------------|
        |                       |
       \|/                     \|/
    <<子系统>>SubSystem1    <<子系统>>SubSystem2
     + Operation             + Operation

    结构:
     + 外观角色: 客户端可以调用这个角色的方法。此角色知晓相关(一个或多个)子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。
     + 子系统角色: 可以同时有一个或多个。每个子系统都不是一个单独的类，而是一个类的集合。每一个子系统都可以被客户端直接调用，或者被外观角色调用 。

    适用场景:
     + 为了一个复杂的系统提供一个简单的接口
     + 提高子系统的独立性
     + 在层次化结构中，可以使用Facade模式定义系统中每一层入口 

    优点:
      + Facade模式实现了子系统与客户端之间的松耦合关系。
      + Facade模式为子系统提供一个集中化和简化的沟通管道
      + 更好地划分访问层次

////////////////////////////////////////////////////////////////////////

17. 享元模式
    定义: 享元对象共享的关键是区分内部状态(Internal State)和外部状态(External State)。内部状态是存储在享元对象内部并且不会随环境改变而改变。因此内部状态可以共享。外部状态是随环境改变而改变的、不可以共享的状态，必须由客户端保存，并在享元对象被创建后，在需要使用的时候再传入到享元对象内部。外部状态与内部状态是相互独立的。

    类图:
        <<享元工厂类>>FlyweightFactory    <----------------- <<抽象享元类>>Flyweight
        + GetFlyweight()                                      + Operation()
              /|\                                               /|\   /|\
               |                                      |----------|     |---------|
               |                                     \|/                        \|/
               |                <<具体享元类>>ConcreteFlyweight            <<不可共享享元类>> UnshareConcreteFlyweight
               |                     + Operation()                 + Operation()
        <<客户类>> Client

    结构:
      + 抽象享元类: 它规定出需要实现的公共接口，那些需要外部状态的操作可以通过方法的参数传入。抽象享元的接口使得享元变得可能，但是并不强制子类实行共享，因此并非所有的享元对象都是可以共享的。
      + 具体享元类: 实现抽象享元类所规定的接口。如果有内部状态的话，必须负责为内部状态提供存储空间。
      + 不能共享的具体享元类: 又叫复合享元类，是由多个单享元对象组成，这些组成的对象是可以共享的，但是复合享元类本身并不能共享。
      + 享元工厂类: 负责创建和管理享元对象。当一个客户端对象请求一个享元对象的时候，享元工厂需要检查系统中是否已经有一个符合要求的享元对象，如果有了，享元工厂角色就应当提供这个已有的享元对象; 如果系统中没有适当的享元对象，享元工厂角色就应当创建一个新的合适的享元对象。
      + 客户类: 需要自行存储所有享元对象的外部状态。
         
    适用场景:
      + 如果一个应用程序使用了大量的对象，而这些对象造成了很大的存储开销时。
      + 对象的大多数状态可变为外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象时
      + 系统中有大量耗费了大量内存的细粒度对象，并且对外界来说这些是透明的

    总结:
      + 享元模式可以避免大量非常相似类的开销。在程序设计中，有时候需要生成大量细粒度的类实例来表示数据。如果能发现这些实例数据除了几个参数外基本都是相同的。有时候就能够大幅度地减少实例化的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传进来，就可以通过共享大幅度地减少单个实例的数目。 如在文档编辑器的设计过程中，我们如果为每个字母创建一个对象的话，系统可能会因为大量的对象而造成存储开销的浪费。如一个字母"A"在文档中出现了100000次，而实际上我们可以让这些字母共享一个对象。当然因为在不同的位置可能字母"A"有不同的显示交易，在这种情况我们可以将对象的状态分为"外部状态"和"内部状态"，将可以被共享的状态作为内部状态存储在对象中，而外部对象我们可以在适当的时候将外部对象作为参数传递给对象。

      + Flyweight的内部状态是用来共享的，FlyweightFactory负责维护一个Flyweight(存放内部状态的对象)，当客户端请求一个共享Flyweight时，这个factory首先搜索池中是否已经有适用的，如果有，factory只是简单地返回这个对象，否则，创建一个新的对象加入池中，再返回这个对象。池为重复或可共享的对象、属性设置一个缓冲，称为内部状态。这些内部状态一般都是不可修改扡就是在第一个对象、属性被创建后就不会去修改了。

      + Flyweight 对对象的内部状态进行共享，只为每种内部状态创建一个实例，使用单例模式。

      + 用户不应直接对ConreteFlyweight类进行实例化，而只能从FlyweightFactory对象得到ConcreteFlyweight对象，这可以保证对它们适当地进行共享。

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
