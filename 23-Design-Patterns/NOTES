////////////////////////////////////////////////////////////////////////
1. 单例模式
   定义: 确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
   类型: 创建类模式
         << 单例类>> Singleton
         - Singleton singleton   <------|
         + Singleton getInstance()  ----|
   包含要素:
       + 私有构造方法
       + 指向自己实例的私有静态引用
       + 以自己实例为返回值的静态的公有的方法

   单例模式根据实例化对象时机的不同分为两种: 一种是饿汉式单例，一种是懒汉式单例。饿汉式单便在单例类被加载时候，就实例化一个对象交给自己的引用; 而懒汉式在调用取得实例方法的时候才会实例化对象。  
   
   优点:
     + 在内存中只有一个对象，节省内存空间
     + 避免频繁的创建销毁对象，可以提高性能
     + 避免对共享资源的多重战胜
     + 可以全局访问

   适用场景:
     + 需要频繁实例化然后销毁的对象
     + 创建对象时耗时过多或者耗资源过多，但又经常用到的对象
     + 有状态的工具类对象
     + 频繁访问数据库或文件的对象
     + 要求只有一个对象的场景

   注意事项:
     + 只能使用单例类提供的方法得到单便对象
     + 不要做断开单例类对象与类中静态引用的危险操作
     + 多线程使用单例共享资源时，注意线程安全问题

////////////////////////////////////////////////////////////////////////
2. 工厂模式
   定义: 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类
           <<工厂接口>>IFactory         <<产品接口>>IProduct
           + createProduct               + productMethod()
                  /\                           /\
                  |                             |
           <<工厂实现>>Factory            <<产品实现>>Product

    工厂模式根据抽象程序的不同分为三种: 简单工厂模式（也叫静态工厂模式),工厂方法模式和抽象工厂模式。
    优点:
      + 可以使代码结构清晰，有效地封装变化。在产品类的实例化时有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品实例化过程 ，只需要依赖工厂即可得到自己想要的产品.
      + 对调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了，即使产品的实现变更了，对调用者来说也没有任何影响。
      + 降低耦合度，产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对调用者来说根本无需知道。

    工厂方法模式:
       + 工厂接口。工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品。在实际中有时候也会使用一个抽象来作为与调用者交互的接口其本质上是一样的。
       + 工厂实现。工厂实现决定如何实例化产品，是实现扩展的途径，需要多少种产品就需要有多少个具体的工厂实现。
       + 产品接口。产品接口的主要目的是定义产品的规范，所有的产品实现都必须遵循产品接口定义的规范，产品接口定义的优劣直接决定了调用者代码的稳定性。同样，产品接口也可以用抽象类来代替，但是注意最好不要违反里氏替换原则 。
       + 产品实现。实现产品接口的具体类，决定了产品在客户端中的具体行为。

    适用场景:
       + 作为一种创建类模式，在任何地方需要生成复杂对象的地方，都可以使用工厂方法模式。而简单对象，特别是只需要通过new就可以创建的对象，无需使用工厂模式。使用工厂模式需要引入一个工厂类，会增加系统的复杂度。如果生产一辆汽车需要组装轮子、发动机、底盘等，过程比较复杂，可以用工厂来封装。
       + 工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现地尤为明显。假如调用自己组装产品需要增加依赖关系时，可以考虑使用工厂模式，将会大大降低对象之间的耦合度。
        + 由于工厂模式是依赖抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。


    抽象工厂模式:
      抽象工厂模式是工厂方法模式的升级版本，它用来创建一组相关或者相互依赖的对象。它与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则是针对多个产品等级结构。在抽象方法中有个产品族的概念，即位于不同产品等级结构中功能相关联的产品组成的家庭。抽象工厂模式所提供的一系列产品就组成一个产品族，而工厂方法提供的一系列产品就称为一个等级结构。
////////////////////////////////////////////////////////////////////////
      优点:
       + 抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束，所谓的产品族，一般或多或少都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述。

      缺点:
       + 产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。

       适用场景:
        + 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。就是一个继承体系中，如果存在着多个等级结构（即存在多个抽象类），并且分属各个等级结构中的实现类之间存在一定的关联或约束，就可以使用抽象工厂模式。

////////////////////////////////////////////////////////////////////////
3. 建造者模式
   定义: 将一个复杂对象的构建与它的表示分享，使得同样的构建过程可以创建不同的表示。

         <<导演类>>Director  -----> <<抽象建造者>>IBuilder
          + getProduct()              + setPart()
                                      + getProduct()
                                          /\
                                           |
                                        <<建造者>>Builer ---> <<产品类>>Product
    四个要素:
     + 产品类: 一般是一个较为复杂的对象，也就是创建对象的过程比较复杂，一般会有较多的代码量。实际中产品类可以是一个抽象类与它的不同实现，也可以是由多个抽象类与它们的实现组成。
     + 抽象建造者: 引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现，这样更容易扩展，一般至少会有两个抽象方法，一个用那建造产品，一个用来返回产品。
     + 建造者: 实现抽象类的所有未实现方法，具体来说一般是两项任务: 组建产品; 返回组建好的产品
     + 导演类: 负责调用适当来组建产品，导演类一般不与产品类发生依赖关系，与导演类直接交互的是建造者类。

    优点:
      + 首先，建造者模式的封装性很好。在使用建造者模式的场景中，一般产品类和建造类是比较稳定的，因此，将主要业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。
      + 建造者模式很容易进行扩展。如果有新需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码。

    建造者模式与工厂模式很像，总体上，建造者模式仅仅比工厂模式多了一个”导演类“角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么剩余的部分就可以看作一个简单的工厂模式了。
    与工厂模式相比，建造者模式一般用来创建一个更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立 出来组成一个新类--导演类。也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品;而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。

////////////////////////////////////////////////////////////////////////
4. 原型模式
   定义: 用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

    <<调用类>>Client -----> <<原型类>>Prototype
                              + clone()
                                  /\
                                  ||
                            <<子类>>ConcretePrototype

    原型模式主要用于对象的复制，它的核心就是原型类Prototype。需要实现Clone函数。对于C++来说，其实就是拷贝构造函数，需实现深拷贝.

    优点:
      + 使用原型模式可以简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。

    注意:
      + 深拷贝与浅拷贝。
////////////////////////////////////////////////////////////////////////


      创建类模式总结:
        + 单例模式: 用于得到内存中的唯一对象
        + 工厂方法模式: 用于创建复杂的对象
        + 抽象工厂方法模式: 用于创建一组相关或相互依赖的复杂对象
        + 建造者模式: 用于创建模块化的更加复杂的对象
        + 原型模式: 用于得到一个对象的拷贝
      
      为什么要使用创建类模式:
         + 在编程中，对象的创建通常是一件比较复杂的事，因为为了达到降低耦合的目的通常会采用面向抽象编程，对象间的关系不会硬编码到类中，而是等到调用的时候再进行组装，这样虽然降低了对象间的耦合，提高了对象复用的可能，但在一定程序上将组装类的任务都交给了最终调用的客户端程序 ，大大增加了客户端的复杂度。采用创建类模式优点之一就是将组装对象的过程封装到一个单独的类中，这样既不会增加对象间的耦合，又可以最大限度的减小客户端的负担。
         + 使用普通的方式创建对象一般是返回一个具体的对象，即所谓的面向实现编程。这与设计模式原则相违背。采用创建类模式则可以实现面向抽象编程。客户端要求的只是一个抽象的类型，具体返回什么样的对象，由创建者决定。
       
      所有的创建类模式本质上都是对对象的创建过程进行封装。

////////////////////////////////////////////////////////////////////////
5. 模板方法模式
   定义: 定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤.
   类型: 行为类模式
   类图: 
         <<抽象类>>AbstractClass
          # otherMethod()
          + templateMethod()
                /\
                ||
            <<实现类>>ConcreteClass
    抽象模板(AbstractClass)角色定义一个或多个抽象操作，以便让子类实现，这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。
    具体模板(ConcreteClass)角色实现父类所定义的一个或多个抽象方法它们是一个顶级逻辑的组成步骤。每个抽象模板角色都可以有任意多个具体模板与之对应，而每一个具体模板角色都可以给出这些抽象方法的不同实现。

    结构:
    + 抽象方法
    + 模板方法
    + 钩子方法
    
    适用性:
    + 一次实现一个算法的不变的部分，并将可变的行为留到子类实现。
    + 各个子类中公共的行为被提取出来并集中到一个公共父类中以避免代码重复。
    + 控制子类的扩展。模板方法只在特定点调用"Hook"操作，这样就只允许在这些点进行扩展.

    要点:
    + Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制(虚函数的多态性)为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。
    + 除了可以灵活应对子步骤的变化外，还可以反向控制结构

////////////////////////////////////////////////////////////////////////

6. 中介者模式
   定义: 定义一个中介对象来封装系列对象之间的交互。 中介者使各个对象不需要显示地相互引用，从而使其耦合性松散，而且可以独立地改变他们之间的交互。
   类型: 行为类模式
   类图:
      <<抽象中介者>>Mediator <----- <<同事类>>Colleague
          /\
          ||
        <<实现类>>ConcreteMediator

   结构:
    + 抽象中介者: 定义好同事类对象到中介者对象的接口，用于各个同事类之间的通信。一般包括一个或几个抽象的事件方法，并由子类去实现。
    + 中介实现类: 从抽象中介者继承而来，实现抽象中介者中定义的事件方法。从一个同事类接收消息，然后通过消息影响影响其他同事类。
    + 同事类: 如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。上图中省略了只有一个同事类，实际中一般同事类由多个组成，他们之间相互影响，相互依赖。同事类越多，关系越复杂。并且，同事类也可以表现为继承了同一个抽象类的一组实现。在中介者模式中，同事类之间必须通过中介者才能进行消息传递。


    为什么要使用中介者模式:
     + 一般来说，多个同事类之间相互关联时，他们之间的关系会呈现复杂的网状结构，这是一种过度耦合的架构，既不利于类的复用，也不稳定。
     如果引入中介者模式，那么同事类之间的关系将变成星型结构，中心就是中介者。任何一个类的变动，只会影响类的本身，以及中介者，从而减小系统的耦合。


    中介者模式是一种比较常用的模式，也是一种比较容易被滥用的模式。对于大多数情况，同事类之间的关系不会复杂到混乱不堪的网状结构，因此，大多数情况下，将对象间的依赖关系封装的同事类内部就可以，没有必要非得引入中介者模式。而且中介者承担了较多的责任，所以一旦这个中介对象出了问题，那么整个系统就会受到重大影响。
////////////////////////////////////////////////////////////////////////

7. 观察者模式

   定义: 定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。
   类型: 行为类模式
   类图:
        <<被观察者>>Subject        ---->    <<观察者>>Observer
        - Vector<Observer> vector            + update()
        + attach(Observer o)                     /\
        + detach(Observer o)                     ||
        + notify()                               ||
            /\                          <<实现类>>ConcreteObserver
            ||
        <<子类>>ConcreteSubject      

     编程中经常会有这样的需求: 如果一个对象的状态发生改变，某些与它相关的对象也要随之做出变化。即一个对象要时刻监听着另一个对象，只要它的状态一发生改变，自己随之要做出相应的行动。

     结构:
      + 被观察者: 一个用来存放观察者对象的Vector容器(之所以使用Vector而不使用List，是因为多线程操作时，Vector是安全的，而List则是不安全的)。这个Vector容器是被观察者类的核心。另外还有三个方法: attach方法是向这个容器中添加观察者对象; detach方法是从容器中移除观察者对象; notify方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或具体的类。
      + 观察者: 观察者角色一般是一个接口，它只有一个update方法，在被观察者状态发生变化时，这个方法就会被触发调用。
      + 具体的被观察者: 使用这个角色是为了便于扩展，可以在此角色中定义具体的业务逻辑。
      + 具体的观察者: 观察者接口的具体实现，在这个角色中，将定义观察者对象状态发生变化时所要处理的逻辑。

    适用场合:
    + 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。
    + 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。也就是说，你不希望这些对象是紧密耦合的。

    优点:
    + 观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察聚集，每一个具体观察者都符合一个抽象观察者接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象层次。
    + 观察者模式支持广播通信。被观察者会向所有的登记过的观察者发出通知。

    缺点:
    + 如果一个观察者对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
    + 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃，这一点要注意。
    + 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自洽的方式进行的。
    + 虽然观察者模式可以随时使观察者所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么变化的。


    观察者模式是一种常用的触发机制，它形成一条触发链，依次对各个观察塲方法进行处理。

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
